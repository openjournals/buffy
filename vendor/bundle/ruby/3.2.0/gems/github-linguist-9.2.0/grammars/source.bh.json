{"name":"bh","scopeName":"source.bh","patterns":[{"include":"#comment_like"},{"include":"#numeric_literals"},{"include":"#string_literal"},{"include":"#char_literal"},{"name":"invalid","match":"(?\u003c!@|#)-\\}"},{"name":"constant.language.unit.bh","match":"(\\()\\s*(\\))","captures":{"1":{"name":"punctuation.paren.bh"},"2":{"name":"punctuation.paren.bh"}}},{"name":"constant.language.unit.unboxed.bh","match":"(\\()(#)\\s*(#)(\\))","captures":{"1":{"name":"punctuation.paren.bh"},"2":{"name":"keyword.operator.hash.bh"},"3":{"name":"keyword.operator.hash.bh"},"4":{"name":"punctuation.paren.bh"}}},{"name":"support.constant.tuple.bh","match":"(\\()\\s*,[\\s,]*(\\))","captures":{"1":{"name":"punctuation.paren.bh"},"2":{"name":"punctuation.paren.bh"}}},{"name":"support.constant.tuple.unboxed.bh","match":"(\\()(#)\\s*,[\\s,]*(#)(\\))","captures":{"1":{"name":"punctuation.paren.bh"},"2":{"name":"keyword.operator.hash.bh"},"3":{"name":"keyword.operator.hash.bh"},"4":{"name":"punctuation.paren.bh"}}},{"name":"constant.language.empty-list.bh","match":"(\\[)\\s*(\\])","captures":{"1":{"name":"punctuation.bracket.bh"},"2":{"name":"punctuation.bracket.bh"}}},{"name":"meta.declaration.package.bh","begin":"(\\b(?\u003c!')(package)|^(signature))(\\b(?!'))","end":"(?=\\b(?\u003c!')where\\b(?!'))","patterns":[{"include":"#comment_like"},{"include":"#package_name"},{"include":"#package_exports"},{"name":"invalid","match":"[a-z]+"}],"beginCaptures":{"2":{"name":"keyword.other.package.bh"},"3":{"name":"keyword.other.signature.bh"}}},{"include":"#ffi"},{"name":"meta.declaration.class.bh","begin":"^(\\s*)(class)(\\s+(:?in?)coherent)?(\\b(?!'))","end":"(?x) # Detect end of class declaration:\n         # 'where' keyword\n   (?=(?\u003c!')\\bwhere\\b(?!'))  \n         # Decreasing indentation\n   |(?=\\}|;)      # Explicit indentation\n   |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\n       \\1\\s+\\S    # - more indented, or\n     | \\s*        # - starts with whitespace, followed by:\n       (?: $      #   - the end of the line (i.e. empty line), or\n       |\\{-[^@]   #   - the start of a block comment, or\n       |--+       #   - the start of a single-line comment.\n          (?![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]{}`_\"']]).*$) # non-symbol\n                  # The double dash may not be followed by other operator characters\n                  # (then it would be an operator, not a comment)\n     )","patterns":[{"include":"#comment_like"},{"include":"#where"},{"include":"#type_signature"}],"beginCaptures":{"2":{"name":"keyword.other.class.bh"},"3":{"name":"keyword.other.coherent.bh"}}},{"include":"#role_annotation"},{"name":"meta.declaration.pattern.type.bh","begin":"^(\\s*)(pattern)\\s+(.*?)\\s+(::|∷)(?![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']])","end":"(?x) # Detect end of pattern type definition by decreasing indentation:\n  (?=\\}|;)       # Explicit indentation\n  |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\n      \\1\\s+\\S    # - more indented, or\n    | \\s*        # - starts with whitespace, followed by:\n      (?: $      #   - the end of the line (i.e. empty line), or\n      |\\{-[^@]   #   - the start of a block comment, or\n      |--+       #   - the start of a single-line comment.\n         (?![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]{}`_\"']]).*$) # non-symbol\n                 # The double dash may not be followed by other operator characters\n                 # (then it would be an operator, not a comment)\n    )\n","patterns":[{"include":"#type_signature"}],"beginCaptures":{"2":{"name":"keyword.other.pattern.bh"},"3":{"patterns":[{"include":"#comma"},{"include":"#data_constructor"}]},"4":{"name":"keyword.operator.double-colon.bh"}}},{"name":"meta.declaration.pattern.bh","begin":"^\\s*(pattern)\\b(?!')","end":"(?x) # Detect end of pattern type definition by decreasing indentation:\n  (?=\\}|;)       # Explicit indentation\n  |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\n      \\1\\s+\\S    # - more indented, or\n    | \\s*        # - starts with whitespace, followed by:\n      (?: $      #   - the end of the line (i.e. empty line), or\n      |\\{-[^@]   #   - the start of a block comment, or\n      |--+       #   - the start of a single-line comment.\n         (?![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]{}`_\"']]).*$) # non-symbol\n                 # The double dash may not be followed by other operator characters\n                 # (then it would be an operator, not a comment)\n    )\n","patterns":[{"include":"$self"}],"captures":{"1":{"name":"keyword.other.pattern.bh"}}},{"name":"meta.declaration.$2.algebraic.bh","begin":"(?x)\n  # Data declaration\n  ^(\\s*)(data|newtype|interface|struct)\\s+\n  # Keep consuming characters until:\n  (((?!\n  # the equals symbol or the start of a single-line comment, or\n    (?: \n      (?\u003c![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']]) # non-symbol\n      (?:=|--+)\n      (?![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']])  # non-symbol\n    )\n  # the \"where\" or \"deriving\" keywords, or\n  | (?:\\b(?\u003c!')(?:where|deriving)\\b(?!'))\n  # the start of a block comment.\n  | {-\n  #\n  ).)*)","end":"(?x) # Detect end of data declaration: \n     # Decreasing indentation\n   (?=\\}|;)      # Explicit indentation\n   |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\n       \\1\\s+\\S    # - more indented, or\n     | \\s*        # - starts with whitespace, followed by:\n       (?: $      #   - the end of the line (i.e. empty line), or\n       |\\{-[^@]   #   - the start of a block comment, or\n       |--+       #   - the start of a single-line comment.\n          (?![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]{}`_\"']]).*$) # non-symbol\n                  # The double dash may not be followed by other operator characters\n                  # (then it would be an operator, not a comment)\n     )","patterns":[{"include":"#comment_like"},{"include":"#deriving"},{"include":"#forall"},{"include":"#adt_constructor"},{"include":"#data_context"},{"include":"#record_decl"},{"include":"#type_signature"}],"beginCaptures":{"2":{"name":"keyword.other.$2.bh"},"3":{"name":"keyword.other.$3.bh"},"4":{"patterns":[{"include":"#type_signature"}]}}},{"name":"meta.declaration.type.bh","begin":"(?x)\n  # Type declaration\n  ^(\\s*)(type)(?:\\s+(instance))?\\s+\n  # Keep consuming characters until:\n  (((?!\n  # the equals symbol, the start of a single-line comment, or a type signature\n    (?: \n      (?\u003c![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']]) # non-symbol\n      (?:=|--+|::|∷)\n      (?![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']])  # non-symbol\n    )\n  # the start of a block comment.\n  | {-\n  #\n  ).)*)","end":"(?x) # Detect end of type definition by decreasing indentation:\n  (?=\\}|;)       # Explicit indentation\n  |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\n      \\1\\s+\\S    # - more indented, or\n    | \\s*        # - starts with whitespace, followed by:\n      (?: $      #   - the end of the line (i.e. empty line), or\n      |\\{-[^@]   #   - the start of a block comment, or\n      |--+       #   - the start of a single-line comment.\n         (?![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]{}`_\"']]).*$) # non-symbol\n                 # The double dash may not be followed by other operator characters\n                 # (then it would be an operator, not a comment)\n    )\n","patterns":[{"include":"#type_signature"}],"beginCaptures":{"2":{"name":"keyword.other.type.bh"},"3":{"name":"keyword.other.instance.bh"},"4":{"patterns":[{"include":"#type_signature"}]}}},{"name":"meta.declaration.instance.bh","begin":"^(\\s*)(instance)(\\b(?!'))","end":"(?x) # Detect end of instance declaration:\n  # 'where' keyword\n  (?=\\b(?\u003c!')(where)\\b(?!'))\n  # Decreasing indentation\n  |(?=\\}|;)      # Explicit indentation\n  |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\n      \\1\\s+\\S    # - more indented, or\n    | \\s*        # - starts with whitespace, followed by:\n      (?: $      #   - the end of the line (i.e. empty line), or\n      |\\{-[^@]   #   - the start of a block comment, or\n      |--+       #   - the start of a single-line comment.\n         (?![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]{}`_\"']]).*$) # non-symbol\n                 # The double dash may not be followed by other operator characters\n                 # (then it would be an operator, not a comment)\n    )\n","patterns":[{"include":"#comment_like"},{"include":"#where"},{"include":"#type_signature"}],"beginCaptures":{"2":{"name":"keyword.other.instance.bh"}}},{"name":"meta.import.bh","begin":"^(\\s*)(import)(\\b(?!'))","end":"(?x) # Detect end of import\n  # 'where' keyword\n  (?=\\b(?\u003c!')(where)\\b(?!'))\n  # Decreasing indentation\n  |(?=\\}|;)      # Explicit indentation\n  |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\n      \\1\\s+\\S    # - more indented, or\n    | \\s*        # - starts with whitespace, followed by:\n      (?: $      #   - the end of the line (i.e. empty line), or\n      |\\{-[^@]   #   - the start of a block comment, or\n      |--+       #   - the start of a single-line comment.\n         (?![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]{}`_\"']]).*$) # non-symbol\n                 # The double dash may not be followed by other operator characters\n                 # (then it would be an operator, not a comment)\n    )\n","patterns":[{"include":"#comment_like"},{"include":"#where"},{"match":"(qualified|as|hiding)","captures":{"1":{"name":"keyword.other.$1.bh"}}},{"include":"#package_name"},{"include":"#package_exports"}],"beginCaptures":{"2":{"name":"keyword.other.import.bh"}}},{"include":"#deriving"},{"include":"#layout_herald"},{"include":"#keyword"},{"name":"meta.fixity-declaration.bh","match":"^\\s*(infix[lr]?)\\s+(.*)","captures":{"1":{"name":"keyword.other.fixity.$1.bh"},"2":{"patterns":[{"include":"#comment_like"},{"include":"#integer_literals"},{"name":"constant.other.operator.infix.bh","match":":[\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']]*"},{"include":"#infix_op"}]}}},{"include":"#start_type_signature"},{"include":"#overloaded_label"},{"include":"#type_application"},{"include":"#reserved_symbol"},{"include":"#fun_decl"},{"include":"#qualifier"},{"name":"constant.other.operator.infix.bh","match":":[\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']]*"},{"include":"#data_constructor"},{"include":"#prefix_op"},{"include":"#infix_op"},{"begin":"(\\()(#)\\s","end":"(#)(\\))","patterns":[{"include":"#comma"},{"include":"$self"}],"beginCaptures":{"1":{"name":"punctuation.paren.bh"},"2":{"name":"keyword.operator.hash.bh"}},"endCaptures":{"1":{"name":"keyword.operator.hash.bh"},"2":{"name":"punctuation.paren.bh"}}},{"begin":"(\\()","end":"(\\))","patterns":[{"include":"#comma"},{"include":"$self"}],"beginCaptures":{"1":{"name":"punctuation.paren.bh"}},"endCaptures":{"1":{"name":"punctuation.paren.bh"}}},{"include":"#quasi_quote"},{"begin":"(\\[)","end":"(\\])","patterns":[{"include":"#comma"},{"include":"$self"}],"beginCaptures":{"1":{"name":"punctuation.bracket.bh"}},"endCaptures":{"1":{"name":"punctuation.bracket.bh"}}},{"include":"#record"}],"repository":{"adt_constructor":{"patterns":[{"include":"#comment_like"},{"begin":"(?x)\n  (?\u003c![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']]) # non-symbol\n  (?:(=)|(\\|))\n  (?![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']])  # non-symbol","end":"(?x)\n  (?: # Infix data constructor\n    # First argument\n    (?:\n    # Simple type\n      (?\u003c!')\\b((?:[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'\\.])+)\n    # Type inside balanced parentheses\n    | ('? # Optional promotion tick\n        (?\u003cparen\u003e\n          \\(          # Opening parenthesis\n          (?:\n            [^\\(\\)]*  # Match non-parentheses\n          | \\g\u003cparen\u003e # or recurse into further depth\n          )*\n          \\)          # Closing parenthesis\n        )\n      )\n    # Type inside balanced brackets\n    | ('? # Optional promotion tick\n        (?\u003cbrac\u003e\n          \\[          # Opening bracket\n          (?:\n            [^\\[\\]]*  # Match non-brackets\n          | \\g\u003cbrac\u003e  # or recurse into further depth\n          )*\n          \\]          # Closing bracket\n        )\n      )\n    )\n    # Then either\n    \\s*\n      # - a symbolic infix constructor, or\n    (?:(?\u003c![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']])(:[\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']]*)\n      # - an alphabetic infix constructor\n    | (`)([\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)(`)\n    )\n  ) # Otherwise, prefix data constructor, either:\n  | # - an alphabetic data constructor e.g. \"Cons_123\"\n    (?:(?\u003c!')\\b([\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*))\n  | # - a symbolic (prefix) data constructor\n    (\\()\\s*(:[\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']]*)\\s*(\\))\n  | # Otherwise, try to fail early to avoid excessive backtracking (https://github.com/JustusAdam/language-bh/issues/161)\n      # Fail when detecting a lowercase identifier and then something not starting with a tick or colon\n      (?=\\b(?\u003c!')(?!(?:forall|deriving)\\s)[\\p{Ll}_]\\S+\\s+[^`:])\n      # Fail when seeing another equal signs or pipe symbol\n     |(?=\n        (?\u003c![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']]) # non-symbol\n        (?:=|\\|)\n        (?![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']])  # non-symbol\n      )","patterns":[{"include":"#comment_like"},{"include":"#deriving"},{"include":"#record_decl"},{"include":"#forall"},{"include":"#data_context"},{"include":"#type_signature"}],"beginCaptures":{"1":{"name":"keyword.operator.eq.bh"},"2":{"name":"keyword.operator.pipe.bh"}},"endCaptures":{"1":{"patterns":[{"include":"#type_signature"}]},"10":{"name":"constant.other.bh"},"11":{"name":"punctuation.paren.bh"},"12":{"name":"constant.other.operator.prefix.bh"},"13":{"name":"punctuation.paren.bh"},"2":{"patterns":[{"include":"#type_signature"}]},"4":{"patterns":[{"include":"#type_signature"}]},"6":{"name":"constant.other.operator.infix.bh"},"7":{"name":"punctuation.backtick.bh"},"8":{"name":"constant.other.infix.bh"},"9":{"name":"punctuation.backtick.bh"}}}]},"block_comment":{"name":"comment.block.bh","begin":"\\{-","end":"-\\}","patterns":[{"include":"#block_comment"}],"captures":{"0":{"name":"punctuation.definition.comment.bh"}},"applyEndPatternLast":true},"char_literal":{"name":"string.quoted.single.bh","match":"(?x)\n  (?\u003c![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])\n  (')\n  (?:\n    [\\ -\\[\\]-~]                         # Basic Char\n  | (\\\\(?:NUL|SOH|STX|ETX|EOT|ENQ|ACK|BEL|BS|HT|LF|VT|FF|CR|SO|SI|DLE\n       |DC1|DC2|DC3|DC4|NAK|SYN|ETB|CAN|EM|SUB|ESC|FS|GS|RS\n       |US|SP|DEL|[abfnrtv\\\\\\\"'\\\\\u0026]))   # Escapes\n  | (\\\\o[0-7]+)                         # Octal Escapes\n  | (\\\\x[0-9A-Fa-f]+)                   # Hexadecimal Escapes\n  | (\\\\\\^[A-Z@\\[\\]\\\\\\^_])                 # Control Chars\n  )\n  (')\n","captures":{"1":{"name":"punctuation.definition.string.begin.bh"},"2":{"name":"constant.character.escape.bh"},"3":{"name":"constant.character.escape.octal.bh"},"4":{"name":"constant.character.escape.hexadecimal.bh"},"5":{"name":"constant.character.escape.control.bh"},"6":{"name":"punctuation.definition.string.end.bh"}}},"comma":{"name":"punctuation.separator.comma.bh","match":","},"comment_like":{"patterns":[{"include":"#cpp"},{"include":"#pragma"},{"include":"#comments"}]},"comments":{"patterns":[{"name":"comment.block.documentation.bh","begin":"^(\\s*)(--\\s[\\|\\$])","end":"(?=^(?!\\1--+(?![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']])))","beginCaptures":{"2":{"name":"punctuation.whitespace.comment.leading.bh"}}},{"name":"comment.line.documentation.bh","begin":"(^[ \\t]+)?(--(@)\\s)","end":"\\n","beginCaptures":{"1":{"name":"punctuation.whitespace.comment.leading.bh"}}},{"name":"comment.block.documentation.bh","begin":"\\{-\\s?[\\|\\$\\*\\^]","end":"-\\}","patterns":[{"include":"#block_comment"}],"captures":{"0":{"name":"punctuation.definition.comment.bh"}},"applyEndPatternLast":true},{"begin":"(^[ \\t]+)?(?=--+(?![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']]))","end":"(?!\\G)","patterns":[{"name":"comment.line.double-dash.bh","begin":"--","end":"\\n","beginCaptures":{"0":{"name":"punctuation.definition.comment.bh"}}}],"beginCaptures":{"1":{"name":"punctuation.whitespace.comment.leading.bh"}}},{"include":"#block_comment"}]},"cpp":{"name":"meta.preprocessor.c","match":"^(#).*$","captures":{"1":{"name":"punctuation.definition.preprocessor.c"}}},"data_constructor":{"patterns":[{"name":"constant.other.bh","match":"\\b(?\u003c!')[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?![\\.'\\w])"},{"name":"constant.other.operator.bh","match":"(\\()\\s*(:[\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']]*)\\s*(\\))"}]},"data_context":{"match":"(?x)\n  (.*)\n  (?\u003c![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']])\n  (=\u003e|⇒)\n  (?![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']])\n","captures":{"1":{"patterns":[{"include":"#comment_like"},{"include":"#forall"},{"begin":"(?='?\\()","end":"(?=\\))","patterns":[{"include":"#type_signature"}]},{"begin":"(?='?\\[)","end":"(?=\\])","patterns":[{"include":"#type_signature"}]},{"match":"(?x)\n  (\\S*)\\s*\n  (?\u003c![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']])\n  (::|∷|=)\n  (?![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']])","captures":{"1":{"patterns":[{"include":"#comment_like"},{"include":"#forall"},{"include":"#record_decl_field"}]},"2":{"patterns":[{"include":"#reserved_symbol"}]},"3":{"patterns":[{"include":"#type_signature"}]}}},{"include":"#type_signature"}]},"2":{"name":"keyword.operator.big-arrow.bh"}}},"deriving":{"patterns":[{"name":"meta.deriving.bh","begin":"^(\\s*)(deriving)\\s+(?:(via|stock|newtype|anyclass)\\s+)?","end":"(?x) # Detect end of deriving statement\n  # Decreasing indentation\n   (?=\\}|;)      # Explicit indentation\n  |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\n      \\1\\s+\\S    # - more indented, or\n    | \\s*        # - starts with whitespace, followed by:\n      (?: $      #   - the end of the line (i.e. empty line), or\n      |\\{-[^@]   #   - the start of a block comment, or\n      |--+       #   - the start of a single-line comment.\n         (?![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]{}`_\"']]).*$) # non-symbol\n                 # The double dash may not be followed by other operator characters\n                 # (then it would be an operator, not a comment)\n    )","patterns":[{"include":"#comment_like"},{"name":"keyword.other.instance.bh","match":"(?\u003c!')\\b(instance)\\b(?!')"},{"match":"(?\u003c!')\\b(via|stock|newtype|anyclass)\\b(?!')","captures":{"1":{"name":"keyword.other.deriving.strategy.$1.bh"}}},{"include":"#type_signature"}],"beginCaptures":{"2":{"name":"keyword.other.deriving.bh"},"3":{"name":"keyword.other.deriving.strategy.$3.bh"}}},{"name":"meta.deriving.bh","begin":"(deriving)(?:\\s+(stock|newtype|anyclass))?\\s*(\\()","end":"(\\))","patterns":[{"include":"#type_signature"}],"beginCaptures":{"1":{"name":"keyword.other.deriving.bh"},"2":{"name":"keyword.other.deriving.strategy.$2.bh"},"3":{"name":"punctuation.paren.bh"}},"endCaptures":{"1":{"name":"punctuation.paren.bh"}}},{"name":"meta.deriving.bh","match":"(?x)\n  (deriving)(?:\\s+(stock|newtype|anyclass))?\\s+\n    ([\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)\n    (\\s+(via)\\s+(.*)$)?\n","captures":{"1":{"name":"keyword.other.deriving.bh"},"2":{"name":"keyword.other.deriving.strategy.$2.bh"},"3":{"patterns":[{"include":"#type_signature"}]},"5":{"name":"keyword.other.deriving.strategy.via.bh"},"6":{"patterns":[{"include":"#type_signature"}]}}},{"name":"keyword.other.deriving.strategy.via.bh","match":"(?\u003c!')\\b(via)\\b(?!')"}]},"double_colon":{"match":"\\s*(::|∷)(?![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']])\\s*","captures":{"1":{"name":"keyword.operator.double-colon.bh"}}},"export_constructs":{"patterns":[{"include":"#comment_like"},{"begin":"\\b(?\u003c!')(pattern)\\b(?!')","end":"(?x)\n   # Data constructor\n   ([\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)\n   # Prefix form of symbolic constructor\n   | (\\()\\s*(:[\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']]+)\\s*(\\))","patterns":[{"include":"#comment_like"}],"beginCaptures":{"1":{"name":"keyword.other.pattern.bh"}},"endCaptures":{"1":{"name":"constant.other.bh"},"2":{"name":"punctuation.paren.bh"},"3":{"name":"constant.other.operator.prefix.bh"},"4":{"name":"punctuation.paren.bh"}}},{"begin":"\\b(?\u003c!')(type)\\b(?!')","end":"(?=,|\\))","patterns":[{"include":"#comment_like"},{"include":"#reserved_symbol"},{"include":"#type_constructor"},{"include":"#type_operator"}],"beginCaptures":{"1":{"name":"keyword.other.type.bh"}}},{"include":"#record_wildcard"},{"include":"#reserved_symbol"},{"name":"storage.type.operator.bh","match":"(\\()\\s*(:[\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']]*)\\s*(\\))"},{"name":"entity.name.function.bh","match":"(?\u003c!')\\b[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*"},{"name":"storage.type.bh","match":"(?\u003c!')\\b[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*"},{"include":"#prefix_op"}]},"ffi":{"name":"meta.$3.foreign.bh","begin":"^(\\s*)(foreign)\\s+(import|export)\\s+","end":"(?x) # Detect end of FFI block by decreasing indentation:\n  (?=\\}|;)       # Explicit indentation\n  |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\n      \\1\\s+\\S    # - more indented, or\n    | \\s*        # - starts with whitespace, followed by:\n      (?: $      #   - the end of the line (i.e. empty line), or\n      |\\{-[^@]   #   - the start of a block comment, or\n      |--+       #   - the start of a single-line comment.\n         (?![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]{}`_\"']]).*$) # non-symbol\n                 # The double dash may not be followed by other operator characters\n                 # (then it would be an operator, not a comment)\n    )\n","patterns":[{"include":"#comment_like"},{"match":"\\b(?\u003c!')(ccall|cplusplus|dotnet|jvm|stdcall|prim|capi)\\s+","captures":{"1":{"name":"keyword.other.calling-convention.$1.bh"}}},{"begin":"(?=\")|(?=\\b(?\u003c!')([\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)\\b(?!'))","end":"(?=(::|∷)(?![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']]))","patterns":[{"include":"#comment_like"},{"match":"(?x)\n  \\b(?\u003c!')(safe|unsafe|interruptible)\\b(?!')\n  \\s*\n  (\"(?:\\\\\"|[^\"])*\")?\n  \\s*\n  (?:\n    (?:\\b(?\u003c!'')([\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)\\b(?!'))\n   |(?:\\(\\s*(?!--+\\))([\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']]+)\\s*\\))\n  )\n","captures":{"1":{"name":"keyword.other.safety.$1.bh"},"2":{"name":"entity.name.foreign.bh","patterns":[{"include":"#string_literal"}]},"3":{"name":"entity.name.function.bh"},"4":{"name":"entity.name.function.infix.bh"}}},{"match":"(?x)\n  \\b(?\u003c!')(safe|unsafe|interruptible)\\b(?!')\n  \\s*\n  (\"(?:\\\\\"|[^\"])*\")?\n  \\s*$\n","captures":{"1":{"name":"keyword.other.safety.$1.bh"},"2":{"name":"entity.name.foreign.bh","patterns":[{"include":"#string_literal"}]}}},{"match":"(?x)\n  \"(?:\\\\\"|[^\"])*\"","captures":{"0":{"name":"entity.name.foreign.bh","patterns":[{"include":"#string_literal"}]}}},{"match":"(?x)\n   (?:\\b(?\u003c!'')([\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)\\b(?!'))\n  |(?:(\\()\\s*(?!--+\\))([\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']]+)\\s*(\\)))\n","captures":{"1":{"name":"entity.name.function.bh"},"2":{"name":"punctuation.paren.bh"},"3":{"name":"entity.name.function.infix.bh"},"4":{"name":"punctuation.paren.bh"}}}]},{"include":"#double_colon"},{"include":"#type_signature"}],"beginCaptures":{"2":{"name":"keyword.other.foreign.bh"},"3":{"name":"keyword.other.$3.bh"}}},"float_literals":{"match":"(?x)\n  \\b(?\u003c!')\n  (?:  # Decimal\n    ([0-9][_0-9]*\\.[0-9][_0-9]*(?:[eE][-+]?[0-9][_0-9]*)?\n    |[0-9][_0-9]*[eE][-+]?[0-9][_0-9]*\n    )\n  |    # Hexadecimal\n    (0[xX]_*[0-9a-fA-F][_0-9a-fA-F]*\\.[0-9a-fA-F][_0-9a-fA-F]*(?:[pP][-+]?[0-9][_0-9]*)?\n    |0[xX]_*[0-9a-fA-F][_0-9a-fA-F]*[pP][-+]?[0-9][_0-9]*\n    )\n  )\\b(?!')","captures":{"1":{"name":"constant.numeric.floating.decimal.bh"},"2":{"name":"constant.numeric.floating.hexadecimal.bh"}}},"forall":{"begin":"(?x)\n  # Alphabetic forall\n  (?:\n  \\b(?\u003c!')\n  (forall)\n  \\b(?!')\n  )\n  |\n  # Symbolic forall\n  (?:\n  # Not preceded by a symbol except reserved symbols\n  (?\u003c![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"'']])\n  (∀)\n  # Not followed by a symbol except reserved symbols\n  (?![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"'']])\n  )","end":"(\\.)|(-\u003e|→)","patterns":[{"include":"#comment_like"},{"include":"#type_variable"},{"include":"#type_signature"}],"beginCaptures":{"1":{"name":"keyword.other.forall.bh"},"2":{"name":"keyword.other.forall.bh"}},"endCaptures":{"1":{"name":"keyword.operator.period.bh"},"2":{"name":"keyword.operator.arrow.bh"}}},"fun_decl":{"name":"meta.function.type-declaration.bh","begin":"(?x)^(\\s*)\n  (primitive\\s+)?\n  (type\\s+)?\n  (?\u003cfn\u003e\n    (?:\n      [\\p{Ll}_\\p{Lu}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*\\#*\n    | \\(\\s*\n        (?!--+\\))\n        [\\p{S}\\p{P}\u0026\u0026[^(),:;\\[\\]`{}_\"']]\n        [\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']]*\n      \\s*\\)\n    )\n    (?:\\s*,\\s*\\g\u003cfn\u003e)?\n  )\n  \\s*(?\u003c![\\p{S}\\p{P}\u0026\u0026[^\\),;\\]`}_\"']])(::|∷)(?![\\p{S}\\p{P}\u0026\u0026[^\\(,;\\[`{_\"']])\n","end":"(?x)\n  # End of type annotation:\n    # To the left of a reserved symbolic keyword such as = or \u003c-\n  (?= \n      # non-symbolic character\n      (?\u003c![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']])\n      # symbolic keyword except (-\u003e)\n      ((\u003c-|←)|(=)|(-\u003c|↢)|(-\u003c\u003c|⤛))\n      # non-symbolic character\n      ([(),;\\[\\]`{}_\"']|[^\\p{S}\\p{P}])\n  )\n  # Decreasing indentation:\n  |(?=\\}|;)      # Explicit indentation\n  |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\n      \\1\\s+\\S    # - more indented, or\n    | \\s*        # - starts with whitespace, followed by:\n      (?: $      #   - the end of the line (i.e. empty line), or\n      |\\{-[^@]   #   - the start of a block comment, or\n      |--+       #   - the start of a single-line comment.\n         (?![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]{}`_\"']]).*$) # non-symbol\n                 # The double dash may not be followed by other operator characters\n                 # (then it would be an operator, not a comment)\n    )\n","patterns":[{"include":"#type_signature"}],"beginCaptures":{"2":{"name":"keyword.other.primitive.bh"},"3":{"name":"keyword.other.type.bh"},"4":{"name":"entity.name.function.bh","patterns":[{"include":"#reserved_symbol"},{"include":"#prefix_op"}]},"5":{"name":"keyword.operator.double-colon.bh"}}},"gadt_constructor":{"patterns":[{"begin":"(?x)\n   ^(\\s*)\n      (?:\n        (\\b(?\u003c!')[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)\n      |(\\()\\s*(:[\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']]*)\\s*(\\))\n      )","end":"(?x)\n  # GADT constructor ends\n  (?=\\b(?\u003c!'')deriving\\b(?!'))  \n        # Decreasing indentation\n  |(?=\\}|;)      # Explicit indentation\n  |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\n      \\1\\s+\\S    # - more indented, or\n    | \\s*        # - starts with whitespace, followed by:\n      (?: $      #   - the end of the line (i.e. empty line), or\n      |\\{-[^@]   #   - the start of a block comment, or\n      |--+       #   - the start of a single-line comment.\n         (?![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]{}`_\"']]).*$) # non-symbol\n                 # The double dash may not be followed by other operator characters\n                 # (then it would be an operator, not a comment)\n    )\n","patterns":[{"include":"#comment_like"},{"include":"#deriving"},{"include":"#double_colon"},{"include":"#record_decl"},{"include":"#type_signature"}],"beginCaptures":{"2":{"name":"constant.other.bh"},"3":{"name":"punctuation.paren.bh"},"4":{"name":"constant.other.operator.prefix.bh"},"5":{"name":"punctuation.paren.bh"}}},{"begin":"(?x)\n  (\\b(?\u003c!')[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}]*) # named constructor\n |(\\()\\s*(:[\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']]*)\\s*(\\))    # prefix operator","end":"(?=;|\\}|$)","patterns":[{"include":"#comment_like"},{"include":"#deriving"},{"include":"#double_colon"},{"include":"#record_decl"},{"include":"#type_signature"}],"beginCaptures":{"1":{"name":"constant.other.bh"},"2":{"name":"punctuation.paren.bh"},"3":{"name":"constant.other.operator.prefix.bh"},"4":{"name":"punctuation.paren.bh"}}}]},"infix_op":{"patterns":[{"match":"(?x)\n  ((?:(?\u003c!'')('')?[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'']*\\.)*)\n    (\\#+|[\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']]+(?\u003c!\\#))","captures":{"1":{"name":"keyword.operator.promotion.bh"},"2":{"name":"entity.name.namespace.bh"},"3":{"name":"keyword.operator.infix.bh"}}},{"name":"keyword.operator.function.infix.bh","match":"(`)((?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'']*\\.)*)([\\p{Ll}\\p{Lu}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'']*)(`)","captures":{"1":{"name":"punctuation.backtick.bh"},"2":{"name":"entity.name.namespace.bh"},"3":{"patterns":[{"include":"#data_constructor"}]},"4":{"name":"punctuation.backtick.bh"}}}]},"inline_phase":{"name":"meta.inlining-phase.bh","begin":"\\[","end":"\\]","patterns":[{"name":"punctuation.tilde.bh","match":"~"},{"include":"#integer_literals"},{"name":"invalid","match":"\\w*"}],"beginCaptures":{"0":{"name":"punctuation.bracket.bh"}},"endCaptures":{"0":{"name":"punctuation.bracket.bh"}}},"integer_literals":{"match":"(?x)\n  \\b(?\u003c!')\n  (?:\n    ([0-9][_0-9]*)                    # Decimal integer\n  | (0[xX]_*[0-9a-fA-F][_0-9a-fA-F]*) # Hexadecimal integer\n  | (0[oO]_*[0-7][_0-7]*)             # Octal integer\n  | (0[bB]_*[01][_01]*)               # Binary integer\n  )\n  \\b(?!')","captures":{"1":{"name":"constant.numeric.integral.decimal.bh"},"2":{"name":"constant.numeric.integral.hexadecimal.bh"},"3":{"name":"constant.numeric.integral.octal.bh"},"4":{"name":"constant.numeric.integral.binary.bh"}}},"keyword":{"match":"\\b(?\u003c!')(?:(where|when|let|letseq|in)|(do|module|rules|action|if|then|else|case(?:s)?|of|verilog|synthesize))\\b(?!')","captures":{"1":{"name":"keyword.other.$1.bh"},"2":{"name":"keyword.control.$2.bh"}}},"layout_herald":{"begin":"(?x)\n  (?:(?\u003c!')\\b(?:(where|let|letseq|do|module|rules|action)|(of))|(\\\\\\s*case(?:s)?))\n  \\s*(\\{)(?!-)","end":"(\\})","patterns":[{"include":"$self"},{"name":"punctuation.semicolon.bh","match":";"}],"beginCaptures":{"1":{"name":"keyword.other.$1.bh"},"2":{"name":"keyword.control.of.bh"},"3":{"name":"keyword.control.lambda-case.bh"},"4":{"name":"punctuation.brace.bh"}},"endCaptures":{"1":{"name":"punctuation.brace.bh"}}},"numeric_literals":{"patterns":[{"include":"#float_literals"},{"include":"#integer_literals"}]},"overloaded_label":{"patterns":[{"name":"entity.name.label.bh","match":"(?x) \n  (?\u003c![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\\p{S}\\p{P}\u0026\u0026[^(,;\\[`{]]) # Disallow closing characters\n  (\\#)\n    (?:\n    # String\n    (\"(?:\\\\\"|[^\"])*\")\n    # Sequence of allowed label identifiers\n    |[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'\\.]+\n    )","captures":{"1":{"name":"keyword.operator.prefix.hash.bh"},"2":{"patterns":[{"include":"#string_literal"}]}}}]},"package_exports":{"name":"meta.declaration.exports.bh","begin":"\\(","end":"\\)","patterns":[{"include":"#comment_like"},{"match":"\\b(?\u003c!')(package)\\b(?!')","captures":{"1":{"name":"keyword.other.package.bh"}}},{"include":"#comma"},{"include":"#export_constructs"},{"begin":"\\(","end":"\\)","patterns":[{"include":"#comment_like"},{"include":"#record_wildcard"},{"name":"constant.other.operator.prefix.bh","match":"(\\()\\s*(:[\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']]*)\\s*(\\))"},{"include":"#export_constructs"},{"include":"#comma"}],"beginCaptures":{"0":{"name":"punctuation.paren.bh"}},"endCaptures":{"0":{"name":"punctuation.paren.bh"}}}],"beginCaptures":{"0":{"name":"punctuation.paren.bh"}},"endCaptures":{"0":{"name":"punctuation.paren.bh"}},"applyEndPatternLast":true},"package_name":{"name":"entity.name.namespace.bh","match":"(?\u003cconid\u003e[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(\\.\\g\u003cconid\u003e)?)"},"pragma":{"name":"meta.preprocessor.bh","begin":"\\{-#","end":"#-\\}","patterns":[{"include":"#comments"},{"name":"keyword.other.preprocessor.pragma.bh","match":"(?xi) \\b(?\u003c!')\n  (synthesize|verilog|noReady|alwaysEnabled|parameter|no_default_clock|no_default_reset|gate_input_clocks|clock_family|clock_prefix|gate_prefix|reset_prefix|alwaysReady|noReady|alwaysEnabled|scanInsert|bitBlast|CLK|RSTN|options|deprecate|properties)\\b(?!')"},{"name":"keyword.other.preprocessor.pragma.bh","match":"(?xi) \\b(?\u003c!')\n  (prefixs?|arg_names|ready|enable|result|always_ready|always_enabled)\\b(?!')"}]},"prefix_op":{"patterns":[{"match":"(?x)\n  (\\()\\s*(?!(?:--+|\\.\\.)\\))(\\#+|[\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']]+(?\u003c!\\#))\\s*(\\))","captures":{"1":{"name":"punctuation.paren.bh"},"2":{"name":"entity.name.function.infix.bh"},"3":{"name":"punctuation.paren.bh"}}}]},"qualifier":{"name":"entity.name.namespace.bh","match":"\\b(?\u003c!')[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*\\."},"quasi_quote":{"patterns":[{"name":"meta.quasi-quotation.bh","begin":"(?x)\n  (\\[)\n  (e|d|p)?\n  (\\|(?:\\|(?!\\]))?)","end":"\\3\\]","patterns":[{"include":"$self"}],"beginCaptures":{"1":{"name":"keyword.operator.quasi-quotation.begin.bh"},"2":{"name":"entity.name.quasi-quoter.bh"},"3":{"name":"keyword.operator.quasi-quotation.begin.bh"}},"endCaptures":{"0":{"name":"keyword.operator.quasi-quotation.end.bh"}}},{"name":"meta.quasi-quotation.bh","begin":"(?x)\n  (\\[)\n  (t)\n  (\\|(?:\\|(?!\\]))?)","end":"\\3\\]","patterns":[{"include":"#type_signature"}],"beginCaptures":{"1":{"name":"keyword.operator.quasi-quotation.begin.bh"},"2":{"name":"entity.name.quasi-quoter.bh"},"3":{"name":"keyword.operator.quasi-quotation.begin.bh"}},"endCaptures":{"0":{"name":"keyword.operator.quasi-quotation.end.bh"}}},{"name":"meta.quasi-quotation.bh meta.embedded.block.$5","begin":"(?x)\n  (\\[)\n  (?:(\\$\\$)|(\\$))?\n  (?!'\\|')                                             # Don't parse ['|'...] as a quasi quotation\n  ((?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*\\.)*) # Optional qualifier\n  ((?:[^\\s\\p{S}\\p{P}]|['_])*)                          # Quasi-quoter\n  (\\|)","end":"\\|\\]","beginCaptures":{"1":{"name":"keyword.operator.quasi-quotation.begin.bh"},"2":{"name":"keyword.operator.prefix.double-dollar.bh"},"3":{"name":"keyword.operator.prefix.dollar.bh"},"4":{"name":"entity.name.namespace.bh"},"5":{"name":"entity.name.quasi-quoter.bh"},"6":{"name":"keyword.operator.quasi-quotation.begin.bh"}},"endCaptures":{"0":{"name":"keyword.operator.quasi-quotation.end.bh"}}}]},"record":{"name":"meta.record.bh","begin":"({)(?!-)","end":"(?\u003c!-)(})","patterns":[{"include":"#comment_like"},{"include":"#record_field"}],"beginCaptures":{"1":{"name":"punctuation.brace.bh"}},"endCaptures":{"1":{"name":"punctuation.brace.bh"}}},"record_decl":{"name":"meta.record.definition.bh","begin":"({)(?!-)","end":"(?\u003c!-)(})","patterns":[{"include":"#comment_like"},{"include":"#record_decl_field"}],"beginCaptures":{"1":{"name":"punctuation.brace.bh"}},"endCaptures":{"1":{"name":"punctuation.brace.bh"}}},"record_decl_field":{"begin":"(?x)\n  (?:([\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)\n    |(\\()\\s*([\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']]+)\\s*(\\))\n  )\n","end":"(,)|(?=})","patterns":[{"include":"#comment_like"},{"include":"#comma"},{"include":"#double_colon"},{"include":"#type_signature"},{"include":"#record_decl_field"}],"beginCaptures":{"1":{"name":"variable.other.member.definition.bh"},"2":{"name":"punctuation.paren.bh"},"3":{"name":"variable.other.member.definition.bh"},"4":{"name":"punctuation.paren.bh"}},"endCaptures":{"1":{"name":"punctuation.comma.bh"}}},"record_field":{"patterns":[{"begin":"(?x)\n  (?:([\\p{Ll}\\p{Lu}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\\.']*)\n    |(\\()\\s*([\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']]+)\\s*(\\))\n  )\n","end":"(,)|(?=})","patterns":[{"include":"#comment_like"},{"include":"#comma"},{"include":"$self"}],"beginCaptures":{"1":{"name":"variable.other.member.bh","patterns":[{"include":"#qualifier"}]},"2":{"name":"punctuation.paren.bh"},"3":{"name":"variable.other.member.bh"},"4":{"name":"punctuation.paren.bh"}},"endCaptures":{"1":{"name":"punctuation.comma.bh"}}},{"include":"#record_wildcard"}]},"record_wildcard":{"match":"(?x)\n  (?\u003c![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']])\n  (\\.\\.)\n  (?![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']])","captures":{"1":{"name":"variable.other.member.wildcard.bh"}}},"reserved_symbol":{"patterns":[{"match":"(?x)\n  (?\u003c![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"'']])\n  (?:\n     (\\.\\.)\n    |(:)\n    |(=)\n    |(\\\\)     # λ not reserved as it is a letter\n    |(\\|)\n    |(\u003c-|←)\n    |(-\u003e|→)\n    |(-\u003c|↢)\n    |(-\u003c\u003c|⤛)\n    |(\u003e-|⤚)\n    |(\u003e\u003e-|⤜)\n  )\n  (?![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"'']])","captures":{"1":{"name":"keyword.operator.double-dot.bh"},"10":{"name":"keyword.operator.arrow.tail.bh"},"11":{"name":"keyword.operator.arrow.tail.double.bh"},"2":{"name":"keyword.operator.colon.bh"},"3":{"name":"keyword.operator.eq.bh"},"4":{"name":"keyword.operator.lambda.bh"},"5":{"name":"keyword.operator.pipe.bh"},"6":{"name":"keyword.operator.arrow.left.bh"},"7":{"name":"keyword.operator.arrow.bh"},"8":{"name":"keyword.operator.arrow.left.tail.bh"},"9":{"name":"keyword.operator.arrow.left.tail.double.bh"}}},{"match":"(?x)\n  (?\u003c=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\\p{S}\\p{P}\u0026\u0026[^\\#,;\\[`{]]) # Require closing characters\n  (\\#+)\n  (?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\\p{S}\\p{P}\u0026\u0026[^),;\\]`}]])   # Disallow opening character","captures":{"1":{"name":"keyword.operator.postfix.hash.bh"}}},{"match":"(?x)\n  (?\u003c=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'\\)\\}\\]]) # Require closing characters\n  (@)\n  (?=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'\\(\\[\\{]) # Require opening character","captures":{"1":{"name":"keyword.operator.infix.tight.at.bh"}}},{"match":"(?x)\n  (?\u003c![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\\p{S}\\p{P}\u0026\u0026[^(,;\\[`{]])  # Disallow closing characters\n  (?:(~)|(!)|(-)|(\\$\\$)|(\\$)|(%))\n  (?=[\\p{Ll}_'\\p{Lu}\\p{Lt}\\p{Nd}\\(\\{\\[]) # Require opening character (non operator symbol)","captures":{"1":{"name":"keyword.operator.prefix.tilde.bh"},"2":{"name":"keyword.operator.prefix.bang.bh"},"3":{"name":"keyword.operator.prefix.minus.bh"},"4":{"name":"keyword.operator.prefix.double-dollar.bh"},"5":{"name":"keyword.operator.prefix.dollar.bh"},"6":{"name":"keyword.operator.prefix.modifier.bh"}}}]},"role_annotation":{"patterns":[{"name":"meta.role-annotation.bh","begin":"^(\\s*)(type)\\s+(role)\\b(?!')","end":"(?x) # Detect end of block by decreasing indentation:\n  (?=\\}|;)       # Explicit indentation\n  |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\n      \\1\\s+\\S    # - more indented, or\n    | \\s*        # - starts with whitespace, followed by:\n      (?: $      #   - the end of the line (i.e. empty line), or\n      |\\{-[^@]   #   - the start of a block comment, or\n      |--+       #   - the start of a single-line comment.\n         (?![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]{}`_\"']]).*$) # non-symbol\n                 # The double dash may not be followed by other operator characters\n                 # (then it would be an operator, not a comment)\n    )","patterns":[{"include":"#comment_like"},{"include":"#type_constructor"},{"match":"\\b(?\u003c!')(nominal|representational|phantom)\\b(?!')","captures":{"1":{"name":"keyword.other.role.$1.bh"}}}],"beginCaptures":{"2":{"name":"keyword.other.type.bh"},"3":{"name":"keyword.other.role.bh"}}}]},"start_type_signature":{"patterns":[{"name":"meta.type-declaration.bh","begin":"^(\\s*)(::|∷)(?![\\p{S}\\p{P}\u0026\u0026[^\\(,;\\[`{_\"']])\\s*","end":"(?x)\n  # End type annotation when seeing one of:\n  (?=\n    \\#?\\)                             # closing parenthesis\n    |\\]                               # closing bracket\n    |,                                # comma\n    |(?\u003c!')\\b(in|then|else|of)\\b(?!') # keyword\n    |                                 # symbolic keyword except (-\u003e)\n      (?\u003c![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']])\n      (?:\n         (\\\\|λ)\n        |(\u003c-|←)\n        |(=)\n        |(-\u003c|↢)\n        |(-\u003c\u003c|⤛)\n      )\n      ([(),;\\[\\]`{}_\"']|[^\\p{S}\\p{P}])\n    |(\\#|@)-\\}                             # End of annotation block (pragma)\n    # Decreasing indentation:\n    | (?=\\}|;)     # Explicit indentation\n    |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\n        \\1\\s*\\S    # - equally indented, or\n      | \\s*        # - starts with whitespace, followed by:\n        (?: $      #   - the end of the line (i.e. empty line), or\n        |\\{-[^@]   #   - the start of a block comment, or\n        |--+       #   - the start of a single-line comment.\n           (?![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]{}`_\"']]).*$) # non-symbol\n                   # The double dash may not be followed by other operator characters\n                   # (then it would be an operator, not a comment)\n      )\n  )","patterns":[{"include":"#type_signature"}],"beginCaptures":{"2":{"name":"keyword.operator.double-colon.bh"}}},{"begin":"(?\u003c![\\p{S}\\p{P}\u0026\u0026[^\\(,;\\[`{_\"']])(::|∷)(?![\\p{S}\\p{P}\u0026\u0026[^\\(,;\\[`{_\"']])","end":"(?x)\n  # End type annotation when seeing one of:\n  (?=\n    \\#?\\)                             # closing parenthesis\n    |\\]                               # closing bracket\n    |,                                # comma\n    |\\b(?\u003c!')(in|then|else|of)\\b(?!') # keyword\n    |(\\#|@)-\\}                        # End of annotation block (Liquidbh or pragma)\n    |                                 # symbolic keyword except (-\u003e)\n      (?\u003c![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']])\n      (?:\n         (\\\\|λ)\n        |(\u003c-|←)\n        |(=)\n        |(-\u003c|↢)\n        |(-\u003c\u003c|⤛)\n      )\n      ([(),;\\[\\]`{}_\"']|[^\\p{S}\\p{P}])\n    # Indentation \n    |(?=\\}|;)      # Explicit indentation\n    |$             # End of line\n  )","patterns":[{"include":"#type_signature"}],"beginCaptures":{"1":{"name":"keyword.operator.double-colon.bh"}}}]},"string_literal":{"name":"string.quoted.double.bh","begin":"\"","end":"\"","patterns":[{"name":"constant.character.escape.bh","match":"\\\\(NUL|SOH|STX|ETX|EOT|ENQ|ACK|BEL|BS|HT|LF|VT|FF|CR|SO|SI|DLE|DC1|DC2|DC3|DC4|NAK|SYN|ETB|CAN|EM|SUB|ESC|FS|GS|RS|US|SP|DEL|[abfnrtv\\\\\\\"'\\\u0026])"},{"name":"constant.character.escape.octal.bh","match":"\\\\o[0-7]+|\\\\x[0-9A-Fa-f]+|\\\\[0-9]+"},{"name":"constant.character.escape.control.bh","match":"\\\\\\^[A-Z@\\[\\]\\\\\\^_]"},{"begin":"\\\\\\s","end":"\\\\","patterns":[{"name":"invalid.illegal.character-not-allowed-here.bh","match":"\\S+"}],"beginCaptures":{"0":{"name":"constant.character.escape.begin.bh"}},"endCaptures":{"0":{"name":"constant.character.escape.end.bh"}}}],"beginCaptures":{"0":{"name":"punctuation.definition.string.begin.bh"}},"endCaptures":{"0":{"name":"punctuation.definition.string.end.bh"}}},"type_application":{"patterns":[{"name":"meta.type-application.bh","match":"(?\u003c=[\\s,;\\[\\]{}\"])(@)(\\(\\s*\\))","captures":{"1":{"name":"keyword.operator.prefix.at.bh"},"2":{"name":"support.constant.unit.bh"}}},{"name":"meta.type-application.bh","begin":"(?\u003c=[\\s,;\\[\\]{}\"])(@)(')?(\\()","end":"\\)","patterns":[{"include":"#type_signature"}],"beginCaptures":{"1":{"name":"keyword.operator.prefix.at.bh"},"2":{"name":"keyword.operator.promotion.bh"},"3":{"name":"punctuation.paren.bh"}},"endCaptures":{"0":{"name":"punctuation.paren.bh"}}},{"name":"meta.type-application.bh","begin":"(?\u003c=[\\s,;\\[\\]{}\"])(@)(')?(\\[)","end":"\\]","patterns":[{"include":"#type_signature"}],"beginCaptures":{"1":{"name":"keyword.operator.prefix.at.bh"},"2":{"name":"keyword.operator.promotion.bh"},"3":{"name":"punctuation.bracket.bh"}},"endCaptures":{"0":{"name":"punctuation.bracket.bh"}}},{"name":"meta.type-application.bh","begin":"(?\u003c=[\\s,;\\[\\]{}\"])(@)(?=\\\")","end":"(?\u003c=\\\")","patterns":[{"include":"#string_literal"}],"beginCaptures":{"1":{"name":"keyword.operator.prefix.at.bh"}}},{"name":"meta.type-application.bh","begin":"(?\u003c=[\\s,;\\[\\]{}\"])(@)(?=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])","end":"(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])","patterns":[{"include":"#type_signature"}],"beginCaptures":{"1":{"name":"keyword.operator.prefix.at.bh"}}}]},"type_constructor":{"patterns":[{"match":"(?x)\n  # Optional promotion tick\n    (')?\n  # Optional qualified name\n    ((?:\\b[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*\\.)*)\n  # Type constructor proper\n    (\\b[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)","captures":{"1":{"name":"keyword.operator.promotion.bh"},"2":{"name":"entity.name.namespace.bh"},"3":{"name":"storage.type.bh"}}},{"match":"(?x)\n  # Optional promotion tick\n    (')?\n  # Opening parenthesis\n    (\\()\\s*\n  # Optional qualified name\n    ((?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*\\.)*)\n  # Type operator proper\n    ([\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']]+)\n  # Closing parenthesis\n    \\s*(\\))","captures":{"1":{"name":"keyword.operator.promotion.bh"},"2":{"name":"punctuation.paren.bh"},"3":{"name":"entity.name.namespace.bh"},"4":{"name":"storage.type.operator.bh"},"5":{"name":"punctuation.paren.bh"}}}]},"type_operator":{"patterns":[{"match":"(?x)\n  # Optional promotion tick\n    (?:(?\u003c!')('))?\n  # Optional qualified name\n    ((?:\\b[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*\\.)*)\n  # Type operator proper\n    (?![#@]?-})(\\#+|[\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']]+(?\u003c!\\#))\n    #((?:[\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']\u0026\u0026[^#@]]|[@#](?!-}))+)","captures":{"1":{"name":"keyword.operator.promotion.bh"},"2":{"name":"entity.name.namespace.bh"},"3":{"name":"storage.type.operator.infix.bh"}}},{"match":"(?x)\n  # Optional promotion tick\n    (')?\n  # Opening backtick\n    (\\`)\n  # Optional qualified name\n    ((?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*\\.)*)\n  # Type constructor proper\n    ([\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)\n  # Closing backtick\n    (`)","captures":{"1":{"name":"keyword.operator.promotion.bh"},"2":{"name":"punctuation.backtick.bh"},"3":{"name":"entity.name.namespace.bh"},"4":{"name":"storage.type.infix.bh"},"5":{"name":"punctuation.backtick.bh"}}}]},"type_signature":{"patterns":[{"include":"#comment_like"},{"name":"support.constant.unit.bh","match":"(')?(\\()\\s*(\\))","captures":{"1":{"name":"keyword.operator.promotion.bh"},"2":{"name":"punctuation.paren.bh"},"3":{"name":"punctuation.paren.bh"}}},{"name":"support.constant.tuple.bh","match":"(')?(\\()\\s*,[\\s,]*(\\))","captures":{"1":{"name":"keyword.operator.promotion.bh"},"2":{"name":"punctuation.paren.bh"},"3":{"name":"punctuation.paren.bh"}}},{"name":"support.constant.empty-list.bh","match":"(')?(\\[)\\s*(\\])","captures":{"1":{"name":"keyword.operator.promotion.bh"},"2":{"name":"punctuation.bracket.bh"},"3":{"name":"punctuation.bracket.bh"}}},{"include":"#integer_literals"},{"name":"keyword.operator.double-colon.bh","match":"(::|∷)(?![\\p{S}\\p{P}\u0026\u0026[^(),;\\[\\]`{}_\"']])"},{"include":"#forall"},{"name":"keyword.operator.big-arrow.bh","match":"=\u003e|⇒"},{"include":"#string_literal"},{"name":"invalid","match":"'[^']'"},{"include":"#type_application"},{"include":"#reserved_symbol"},{"include":"#type_operator"},{"include":"#type_constructor"},{"begin":"(\\()","end":"(\\))","patterns":[{"include":"#comma"},{"include":"#type_signature"}],"beginCaptures":{"1":{"name":"punctuation.paren.bh"}},"endCaptures":{"2":{"name":"punctuation.paren.bh"}}},{"begin":"(')?(\\()","end":"(\\))","patterns":[{"include":"#comma"},{"include":"#type_signature"}],"beginCaptures":{"1":{"name":"keyword.operator.promotion.bh"},"2":{"name":"punctuation.paren.bh"}},"endCaptures":{"1":{"name":"punctuation.paren.bh"}}},{"begin":"(')?(\\[)","end":"(\\])","patterns":[{"include":"#comma"},{"include":"#type_signature"}],"beginCaptures":{"1":{"name":"keyword.operator.promotion.bh"},"2":{"name":"punctuation.bracket.bh"}},"endCaptures":{"1":{"name":"punctuation.bracket.bh"}}},{"include":"#type_variable"}]},"type_variable":{"name":"variable.other.generic-type.bh","match":"\\b(?\u003c!')(?!(?:forall|deriving)\\b(?!'))[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*"},"where":{"patterns":[{"begin":"(?x)\n  (?\u003c!')\\b(where)\n  \\s*(\\{)(?!-)","end":"(\\})","patterns":[{"include":"$self"},{"name":"punctuation.semicolon.bh","match":";"}],"beginCaptures":{"1":{"name":"keyword.other.where.bh"},"2":{"name":"punctuation.brace.bh"}},"endCaptures":{"1":{"name":"punctuation.brace.bh"}}},{"name":"keyword.other.where.bh","match":"\\b(?\u003c!')(where)\\b(?!')"}]}}}
